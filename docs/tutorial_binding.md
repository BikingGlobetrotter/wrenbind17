# Tutorial: Binding C++ class functions

## Member functions and modules

To bind a C++ class, you will first need to create a new module. Creating a new module is done per VM basis. If you have multiple VMs in your application, they won't share the same modules. You would have to create the module for each of your VM instances.

```cpp
wren::VM vm;

// Create module called "mymodule"
auto& m = vm.module("mymodule");
```

You can create as many modules as you want. Additionally, calling the method `module(...)` multiple times with the same name won't create duplicates. For example:

```cpp
wren::VM vm;

auto& m0 = vm.module("mymodule");
auto& m1 = vm.module("mymodule");

// m0 and m1 now point to the exact same module
```

Classes are added into the modules in the following way:

```cpp
class Foo {
public:
    Foo(const std::string& msg) {
        ...
    }

    void bar() {

    }

    int baz() const {

    }
};

wren::VM vm;
auto& m = vm.module("mymodule");

// Add class "Foo"
auto& cls = m.klass<Foo>("Foo");

// Define constructor (you can only specify one constructor)
cls.ctor<const std::string&>();

// Add some methods
cls.func<&Foo::bar>("bar");
cls.func<&Foo::baz>("baz");
```

::: tip
Note!

The class functions (methods) are added as a template argument, not as the function argument. This is due to the how Wren is built. Because of this implementation, you will also get extra performance, because the pointers to the class functions are optimized at compile time.
:::

Now inside of your Wren script, you can do the following:

```js
import "mymodule" for Foo

var foo = Foo.new("Message")
```

Please note that you don't have to manually create file "mymodule.wren" and add all of your C++ foreign classes into it manually. Everything is automatically generated by the `wren::VM`. You can get the "raw" contents of the module that will be put into Wren by simply calling `.str()` on the module (e.g. `vm.module("mymodule").str();`).

## Handling function pointer ambiguity

In case you have multiple functions with the same name, you will have to use `static_cast` to explicitly tell the compiler which function you want. For example:

```cpp
class Foo {
    const std::string& getMsg() const;
    std::string& getMsg();
};

wren::VM vm;
auto& m = vm.module("mymodule");
auto& cls = vm.klass<Foo>("Foo");
cls.func<static_cast<const std::string& (*)(void) const>(&Foo::getMsg)>("getMsg");
```

## Static functions

To add a static function, simply call the `funcStatic` instead of `func` as shown below:

```cpp
class Log {
    static void debug(const std::string& text);
    static void error(const std::string& text);
    static void info(const std::string& text);
};

wren::VM vm;
auto& m = vm.module("mymodule");
auto& cls = m.klass<Log>("Log");
cls.funcStatic<&Log::debug>("debug");
cls.funcStatic<&Log::error>("error");
cls.funcStatic<&Log::info>("info");
```
