# Bind C++ Class

## Basics

Before continuing, I will assumme that you have at least some minimal program such as:

```cpp
#include <wrenbind17/wrenbind17.hpp>
namespace wren = wrenbind17; // Alias

int main(int argc, char *argv[]) {
    const std::string code = R"(
        class Main {
            static main() {
                // stuff
            }
        }
    )";

    // Create new VM
    wren::VM vm;

    // Runs the code from the std::string as a "main" module
    vm.runFromSource("main", code);

    // Find class Main in module main
    auto mainClass = vm.find("main", "Main");

    // Find function main() in class Main
    auto main = mainClass.func("main()");

    // Execute the function
    main();

    return 0;
}
```

To bind a C++ class, you will first need to create a new module. Creating a new module is done per VM basis. If you have multiple VMs in your application, they won't share the same module. You would have to create the module for each VM.

```cpp
wren::VM vm;

// Create module called "mymodule"
auto m = vm.module("mymodule");
```

You can create as many modules as you want. Additionally, calling the method `module(...)` multiple times with the same name won't create duplicates. For example:

```cpp
wren::VM vm;

auto m0 = vm.module("mymodule");
auto m1 = vm.module("mymodule");

// m0 and m1 now point to the exact same module
```

Classes are added into the modules in the following way:

```cpp
class Foo {
public:
    Foo(const std::string& msg) {
        ...
    }

    void bar() {

    }

    int baz() const {

    }
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Foo"
auto& cls = m.klass<Foo>("Foo");

// Define constructor, creates a construct named "new"
cls.ctor<const std::string&>();

// Add some methods
cls.func<&Foo::bar>("bar");
cls.func<&Foo::baz>("baz");
```

Now inside of your Wren script, you can do the following:

```js
import "mymodule" for Foo

var foo = Foo.new("Message")
```

Please note that you don't have to manually create file "mymodule.wren" and add all of your C++ foreign classes into it manually. Everything is automatically generated by the `wren::VM`. 

## Variables via public fields

There are two ways how to add C++ class variables to Wren. 
One way is to have a public field and simply bind it to the Wren:

```cpp
struct Vec3 {
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.var<&Vec3::x>("x");
cls.var<&Vec3::y>("y");
cls.var<&Vec3::z>("z");
```

Equivalent wren code:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x
    foreign x=(rhs)

    foreign y
    foreign y=(rhs)

    foreign z
    foreign z=(rhs)
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new()
v.x = 1.23
v.y = 0.0
v.z = 42.42
```

## Variables via getter and setter

Another way is to have a getter and a setter and bind those to the Wren:

```cpp
class Vec3 {
public:
    float getX() const     { return x; }
    void setX(float value) { x = value; }
    float getY() const     { return y; }
    void setY(float value) { y = value; }
    float getZ() const     { return z; }
    void setZ(float value) { z = value; }
private:
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.prop<&Vec3::getX, &Vec3::setX>("x");
cls.prop<&Vec3::getY, &Vec3::setY>("y");
cls.prop<&Vec3::getZ, &Vec3::setZ>("z");
```

Equivalent wren code:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x
    foreign x=(rhs)

    foreign y
    foreign y=(rhs)

    foreign z
    foreign z=(rhs)
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new()
v.x = 1.23
v.y = 0.0
v.z = 42.42
```

## Read only variables

To bind read-only variables you can use `varReadonly` function. This won't define a Wren setter and therefore the variable can be only read. 

```cpp
class Vec3 {
public:
    Vec3(float x, float y, float z) {...}

    const float x;
    const float y;
    const float z;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.varReadonly<&Vec3::x>("x");
cls.varReadonly<&Vec3::y>("y");
cls.varReadonly<&Vec3::z>("z");
```

Equivalent wren code:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x

    foreign y

    foreign z
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new(1.1, 2.3, 3.3)
System.print("X value is: %(v.x)") // ok
v.x = 1.23 // error
```

For read-only properties, you can use `propReadonly` as shown below:

```cpp
// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.propReadonly<&Vec3::getX>("x");
cls.propReadonly<&Vec3::getY>("y");
cls.propReadonly<&Vec3::getZ>("z");
```

## Abstract classes

What if you want to pass an abstract class to Wren? You can't allocate it. You can only pass it around. Imagine a specific derived "Entity" class that has a common abstract/interface class?

The only thing you have to do is to NOT do add `ctor`

```cpp
wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Entity>("Entity");
// cls.ctor<>(); Do not add constructor!
cls.func<&Entity::foo>("foo");
```

## Static functions

To add a static function, simply call the `funcStatic` instead of `func` as shown below:

```cpp
class Log {
    static void debug(const std::string& text);
    static void error(const std::string& text);
    static void info(const std::string& text);
};

wren::VM vm;
auto m = vm.module("mymodule");
auto& cls = m.klass<Log>("Log");
cls.funcStatic<&Log::debug>("debug");
cls.funcStatic<&Log::error>("error");
cls.funcStatic<&Log::info>("info");
```
